\input texinfo
@c -*- texinfo -*-

@c %**start of header
@setfilename chil.info
@documentencoding UTF-8
@settitle Chil Reference Manual
@c %**end of header

@c This command defines a custom index for acronyms
@defindex ac

@include version.texi

@copying
Copyright @copyright{} 2023 Raven Hallsby@*

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end copying

@titlepage
@title Chil Reference Manual
@subtitle Constructing Hardware in Lisp Language and Simulator
@author Raven Hallsby

@insertcopying
@end titlepage

@contents

@c *********************************************************************
@node Top
@top Chil

This document describes Chil version @value{VERSION}, a hardware
construction language and simulator.  Chil is inspired by
@uref{https://www.chisel-lang.org/, Chisel} and a variety of hardware
simulators.

@menu
* Introduction::                What is Chil?
* Hardware Language::           Chil, the language.
* Chilog::                      Chilog, Datalog in Common Lisp & Chil.
* Optimization::                Optimizing and lowering Chil.
* Code Generation::             Generating other HDLs and IR HDLs.
* Build Artifacts::             Managing & interacting with build artifacts.
* Simulation::                  Simulating Chil.
* Verification::                Verifying Chil.
* Synthesis::                   Synthesizing Chil to hardware.
* Interaction::                 Using Chil from the command-line.
* Resources::                   Resources Chil used for inspiration.
* Contributing::                You can help too!
* Concept Index::               Concepts.
* Programming Index::           Datatypes, functions, and variables.
* Acronym Index::               Acronyms and their expansions.
@end menu

@node Introduction
@chapter Introduction

@cindex purpose
Chil has multiple goals with many lofty goals.
Some or none of these may ever come to pass.

@enumerate
@item
Create and define an embedded domain-specific language@tie{}(EDSL), that
allows for expressing hardware in a reusable and composable way.
@item
Writing out a Chil design to another Hardware Description
Language@tie{}(HDL), whether it be Verilog, VHDL, FIRRTL, CIRCT, or any
other.
@item
When lowering a design from Chil's syntax to another language, use a
nanopass framework for optimizations, to make understanding a single
optimization easier and make adding additional optimization passes
simpler.
@item
Using the nanopass framework also means that a design can be output at
the end of each optimization pass for simulation and formal
verification.  Indeed, we can create special passes to lower to other
formal specification variants which can be verified.
@c Nanopass HDL, certain lowering can output other variants to formally verify.
@item
Create a digital logic simulator that supports snapshotting, interactive
debugging, and time travel.
@item
Include a verification system to formally verify a design in the same
language as the design is written in.
@item
Synthesize to hardware, if possible.
@end enumerate

@emph{Ideally}, Chil will be a language and tool that is the
@uref{https://www.eiffel.org/documentation, Eiffel} of hardware.  Chil
should allow you to express analyses, designs, implementations, and
maintenance, @emph{and} give you tools to further extend the language
for your own needs.

@node Hardware Language
@chapter Hardware Language

@uref{https://www.chisel-lang.org/, Chisel} introduced the world to
using an embedded domain-specific language@tie{}(EDSL) for hardware
design.  In many ways, this brought hardware design languages into the
21st Century.  Chisel allows for designs to:
@itemize
@item
Inherit from multiple sub-component definitions, through direct
object-oriented inheritance or through trait/typeclass/component
composition.
@item
Use functional programming ideas to improve the replication of portions
of the design.  Namely, Chisel uses a strong and strict type system,
makes heavy use of immutability, and frequently uses higher-order
functions to express repeatedly complex operations.
@end itemize

Chisel is built out of and on top of the
@uref{https://www.scala-lang.org/, Scala} software programming language.
While Scala is a fine language, it has some issues as well.  Most
notably (in the author's opinion) is the difficulty in creating new
Chisel components that require altering Chisel's internal behaviors.  As
an example, the author needed to have a directioned@footnote{This means
the input to one module connects to an output from another, as you would
expect. Chisel's default connection operator simply connects the first
signal in one module to the first signal in the other module, and so
on.} connection primitive for a Chisel design.  Chisel had that feature,
but only in the experimental package at the time.

@menu
* Interactive Development::     Building hardware with a REPL!
@end menu

@node Interactive Development
@section Interactive Development

One of the goals of Chil was to provide the ability for users to
@emph{interactively} write their hardware designs.  This is part of the
reason why the hardware language is built on top of a Lisp language.
You can introspect all parts of the language and ``ask'' the language
itself what everything means.  Your code as an end-developer sits at the
same level as the language-provided library code.

@c https://stackoverflow.com/questions/21367083/how-do-i-access-the-documentation-string-of-a-slot-of-a-defclass-in-common-lisp
To find documentation about class slots in, you will have to do the
following: In SBCL:
@example
CHIL> (defclass foo ()
  ((bar
    :accessor bar
    :initarg :bar
    :initform 1
    :type integer
    :documentation "An example slot in a class."))
  (:default-initargs :bar 1)
  (:documentation "An example class."))
#<STANDARD-CLASS CHIL:FOO>

CHIL> (sb-mop:finalize-inheritance *)
NIL

CHIL> (sb-mop::class-slots **)
(#<SB-MOP:STANDARD-EFFECTIVE-SLOT-DEFINITION CHIL::BAR>)

CHIL> (documentation (first *) t)
"An example slot in a class."
@end example

In CCL:
@example
CHIL> (defclass foo ()
  ((bar
    :accessor bar
    :initarg :bar
    :initform 1
    :type integer
    :documentation "An example slot in a class."))
  (:default-initargs :bar 1)
  (:documentation "An example class."))
#<STANDARD-CLASS CHIL:FOO>

CHIL> (sb-mop:finalize-inheritance *)
NIL

CHIL> (sb-mop::class-slots **)
(#<SB-MOP:STANDARD-EFFECTIVE-SLOT-DEFINITION CHIL::BAR>)

CHIL> (documentation (first *) 'slot-definition)
"An example slot in a class."
@end example

@node Chilog
@chapter Chilog

@cindex chilog
Chilog is an implementation of
@uref{https://en.wikipedia.org/wiki/Datalog, Datalog} in Common Lisp.
It is intended to be a way to conveniently model, work with, and produce
declarative logic programs for various uses.  We hope that Chilog serves
as a domain-specific language to express complex tasks more easily and
more correctly.

That being said, because Chilog is a general implementation of Datalog,
it @emph{may} be slower than a custom written tool, because Chilog can
be seen as a ``one size fits all'' tool.  This can be alleviated by
using one of the more complex engines, @pxref{Chilog Engines}.

Chilog's only user (currently) is Chil itself, so there are conveniences
added to the Chilog language to make using the Datalog portions of the
language from Chil itself easier.

Relevant work:
@table @samp
@item Single Python File Na@"{@dotless{i}}ve Implementation
@url{https://btmc.substack.com/p/implementing-logic-programming}

@item Simple & High-Performance Rust Implementation
@url{https://github.com/frankmcsherry/blog/blob/master/posts/2025-06-03.md}

@end table

@menu
* Datalog Terminology::         Phrases, terms, and words used by Datalog.
* Chilog Engines::              Evaluating Chilog programs.
@end menu

@node Datalog Terminology
@section Datalog Terminology

Datalog has a long and rich history in both research work and industrial
programming work. This long history also means that Datalog has
sometimes has specific terminology used that may not be
commonplace. This section aims to be a glossary of sorts so that you can
seamlessly switch between Datalog and Chilog work.

Datalog is both monotonic and confluent.
@itemize
@item
Monotonic: As you add more rules and/or facts, the set of things that
are true only increases.
@item
Confluent: Regardless of what order the rules are in, you will get the
same resulting set of facts.
@end itemize

@deffn {Glossary} {Extensional Database}
The set of facts that the writer pre-installed into the database. These
usually form some kind of ``ground-truth'' about the problem being
represented.

Extensional Database is often shortened to EDB.

Cast in a different light, the EDB is the thing being analyzed.
@end deffn

@deffn {Glossary} {Fact}
A Datalog fact is a tuple of terms that makes the associated
relation/rule always produce true.
@end deffn

@deffn {Glossary} {Intensional Database}
The set of rules/relations that the writer wrote in the program.  These
represent the task at hand (an analysis, traversal, etc.) as Horn clause
formulae over finite domains.  These relations are used in inference and
combined with the Extensional Database to find new facts.
@c combined with the @ref{Extensional Database} to find new facts.

Intensional Database is often shortened to IDB.
@end deffn

@deffn {Glossary} {Relation}
A relation (sometimes called a rule) is part of the Intensional
Database.  Elements of this relation are referred to as tuples.
@c A relation (sometimes called a rule) is part of the @ref{Intensional
@c Database}.  Elements of this relation are referred to as tuples.

Every relation is implicitly universally quantified over the variables
present in the relation, meaning that for any setting of the variables,
if the body is true for some variable settings, then the head is true
for those same settings.
@end deffn

@deffn {Glossary} {Atom}
A relation is composed of atoms.

When viewed in an object-oriented light, an atom is an instantiation of
a predicate with specific values/variables to build a rule.
@end deffn

@deffn {Glossary} {Equivalence Relation}
Equivalence relations are binary relations that are reflexive,
symmetric, and transitive.

Reflexivity: R(a, a) :- R(a, _)

Symmetry: R(a, b) :- R(b, a)

Transitivity: R(a, c) :- R(a, b), R(b, c).
@end deffn

Syntactically (what you are allowed to write), Datalog is a subset of
Prolog.  This is done by adding restrictions to what you can write (or
removing power) from the language.  Restricting the Datalog writer may
seem like a bad idea, but by restricting the language, we make it
Turing-@emph{incomplete}, which allows us to make many guarantees, one
of which is termination.

The largest restriction Datalog enforces is that the programs be
@b{well-formed}.  A well-formed Datalog program is one where for every
relation in the program is well-formed.  A well-formed relation is one
where all variables that appear in the head of the relation appear in
the body.  There are nuances around this requirement depending on what
Datalog ``extensions'' are present.

@example
Datalog programs are @emph{guaranteed} to terminate.
@end example


@node Chilog Engines
@section Chilog Engines

Chilog's evaluation design allows you to decouple the representation and
storage of facts and rules from the process of inferring facts and
answering queries for those rules. The piece that infers facts and
answers queries is ``an engine''.
@cindex Chilog Engine

There are (or will be) several engines, including:
@itemize
@item
A na@"{@dotless{i}}ve interpreter.

This engine recomputes every fact for every rule/relation every time a
unification step is performed.  This means it has terrible runtime
performance, since it ``discovers'' the same facts many times.  However,
it serves as a golden baseline by which to compare the correctness of
the other engines.

@item
A semi-na@"{@dotless{i}}ve interpreter.

The semi-na@"{@dotless{i}}ve engine is an improvement over the
na@"{@dotless{i}}ve one by leveraging Datalog's monotonicity and
confluence properties.  These properties mean that regardless of the
evaluation order of the rules, we will always only @b{add}
information/facts to the database.  This observation means we do not
need to perform unification on facts we discovered previously, but only
on the facts found on the most recent round of unification.

@item
An ``interpreter'' that talks to a SQL database which performs the inference.

For this discussion, assume we have a relation like @t{path/2} below
which attempts to find all paths from node/vertex @t{X} to @t{Z} in some
graph. For the moment, ignore the need to reach a fixed-point.

@example datalog
path(X,Z) :- edge(X,Y), path(Y,Z).
@end example

If you attempt to compute @t{path/2}, you need to find all of
@t{edge/2}'s facts that have a @t{Y} value that matches a fact of
@t{path/2} that has the @b{same} @t{Y} as a source. Since we know the
current state of both @t{edge/2} and @t{path/2}'s facts, we can take a
hint from databases and treat this as a relational algebra @t{JOIN}
(@math{\bowtie}).  In particular, this is an equijoin.

With this knowledge, we can encode each predicate as a SQL table, each
of the predicate's arguments as a column/attribute of the table, and
each fact as a row/tuple in the table.  Then to find new facts, we
@t{JOIN} the two tables based on the shared variables in each of the
atoms in the relation to find an answer.

@item
A synthesizer/compiler.

This engine behaves similar to @uref{https://souffle-lang.github.io,
Souffl@'e}. The Datalog program is written in Chilog, but only the
Intensional Database is considered. These relations are then translated
to more efficient operations and then compiled to a separate binary. The
Extensional Database (facts) are provided as an input to the compiled
program.
@end itemize


@node Optimization
@chapter Optimization

Chil uses a nanopass optimization framework to optimize its high-level
description down to a lower-level language.  @uref{https://nanopass.org,
Nanopass optimization} is an idea from optimizing compiler design.  It
was first described in a whitepaper describing how to teach building
optimizing compilers
(@uref{https://legacy.cs.indiana.edu/~dyb/pubs/nano-jfp.pdf, original
description}). The core idea is that a single optimization pass should
perform just one easily-understood task which will be layered to perform
more advanced optimizations.

Most commercial compilers (including GCC and LLVM) implement
optimization passes that change large amounts of the program being
compiled in a single pass. A criticism of the original whitepaper was
that any nanopass compiler would not produce code as optimized as these
commercial compilers.  However, in Andrew Keep's
@uref{https://andykeep.com/pubs/dissertation.pdf, PhD thesis}, he showed
that many of these small passes is just as effective as commercial
compilers' larger ones.

Using a nanopass optimization methodology to compile Chil's high-level
description of a circuit down to a lower level means that new passes can
be added relatively easily.

Each of the currently supported passes is described in the following
sections.

@menu
* Pass 1::                      The first pass to run.
* Backend Conversion Pass::     Converting to a backend modules.
* Backend Generation Pass::     Generating Backend code from modules.
* Future Passes::               Passes to add in future versions.
@end menu

@node Pass 1
@section Pass 1

This first pass does something.

@node Backend Conversion Pass
@section Backend Conversion Pass

@acindex DAG
The backend conversion pass is the logical connector between a Chil
module and another language that other tools can accept.  This pass is
repsonsible for converting a single Chil design (a @acronym{DAG,
Directed Acyclic Graph} of modules) to a @acronym{DAG} in a backend
language.

The split of phases between conversion and generation is an arbitrary
choice right now.  There is no particular reason that the phases are
organized this way.

Part of the thinking behind this decision was that the separation of
steps may mean that building a task graph will be easier.

@node Backend Generation Pass
@section Backend Generation Pass

The last step that Chil can take is to generate the backend code from
the converted backend design.  The only thing this pass does is generate
a string representation in the backend language of choice, potentially
writing that string to a file.

At this point, if you want Chil to recognize the module again, you will
need to parse it using the appropriate front-end!

@node Future Passes
@section Future Passes

From a collection of sources, I have started a list of passes that may be interesting to add in the future.

@table @samp
@item Application Accelerator Language (Ideas for Passes)
@url{https://youtu.be/breMdZl47Ns?si=3j5mBlpfKO8Cfjtq}
@end table

@node Code Generation
@chapter Code Generation

Chil does @b{not} lock you into using Chil or its tools.  A variety of
backends are supported, allowing you to take your Chil designs
elsewhere, if you choose.

@menu
* Lowering to a Backend::       Generating Backend Modules from Chil.
* Verilog::                     Chil generating Verilog.
* VHDL::                        Chil generating VHDL.
* CIRCT::                       Chil generating LLVM CIRCT.
* FIRRTL::                      Chil generating Chisel FIRRTL.
@end menu

@node Lowering to a Backend
@section Lowering to a Backend

Chil expects to do all of its work on its own intermediate representation.
When producing a different output format, Chil converts its representation of a module to a backend-specific representation.
This backend-specific representation is then used to generate the desired output.

The general flow is:
@example
Input -> Chil -> Optimize -> Chil -> Backend-Specific -> Output Format
@end example

@node Verilog
@section Verilog

Chisel has targeted Verilog/SystemVerilog, because it is easier to
generate syntactically correct SystemVerilog than VHDL.

@node VHDL
@section VHDL

VHDL is another IEEE standardized hardware description language.

@node CIRCT
@section CIRCT

CIRCT is an intermediate representation backed by LLVM's MLIR and its
framework.

@node FIRRTL
@section FIRRTL

FIRRTL is an intermediate representation used by Chisel that is used
only in the first steps of Chisel elaboration.  As soon as a Chisel
design is fully elaborated into FIRRTL, it gets converted to CIRCT, and
most passes against that now.

@node Build Artifacts
@chapter Build Artifacts

Starting as a test idea, Chil will also use a persistent database to
store both intermediate and final build artifacts, indexed by some
features of the code being manipulated.  I have taken this idea from
@uref{https://dl.acm.org/doi/10.1145/291252.288284, Montana}, a compiler
for IBM's customized version of C++.  This compilation model allowed for
complex analyses to be run cheaply over the @emph{syntax tree} of a
translation unit, rather than its IR.  In addition, it offered a way to
introduce interactive and responsive tools before the era of LSPs.
There may be something to leverage here.  This would pair well with the
discussions from
@uref{https://www.microsoft.com/en-us/research/uploads/prod/2018/03/build-systems.pdf,
Build Systems @`{a} la Carte} about intermediate build targets and
determining if something needs to be built.

@node Simulation
@chapter Simulation

@menu
* Logic Simulation::            Simulating the design's logic.
* Physical Simulation::         Simulating the design's physics.
* Property-Based Testing::      Testing the design using properties.
@end menu

@node Logic Simulation
@section Logic Simulation

Chil's simulator, like other HDL simulators, will simulate the design
under ideal digital conditions.  This means wires update their state
instantaneously, the clock is perfectly synchronized throughout the
physical layout, among other assumptions.  This is usually enough to
understand issues with the design at an early stage.

A critical feature in the design of Chil's digital simulator is
@b{@xref{Snapshotting}}.  With snapshotting, when an assertion about the
design is violated, the simulator generates a Common Lisp image with a
REPL that contains all the information about the design's simulation
preceding the violation.  The user is able to open and run this image
and inspect the state of the design at the time of the violation, and
even go backward in time!

For more in-depth simulation, namely of the physical properties of the
hardware, we turn to physical simulation @pxref{Physical Simulation}.

@menu
* Snapshotting::                Stopping the world and investigating.
* Instrumenting::               How to run & instrument simulations.
@end menu

@node Snapshotting
@subsection Snapshotting

The key feature of Chil's simulator is its ability to ``snapshot'' the
design when an assertion is violated.  When such a violation occurs, a
Common Lisp core image is stored on-disk.  This image will include a
@emph{full} Common Lisp REPL inside it, allowing the user to interact
with the design.  Further, by construction, the image and REPL will
allow the user to travel back in time to @b{interactively investigate}
why the design experienced a violation.

@node Instrumenting
@subsection Instrumenting
@c Simulator must have module that is DUT marked/annotated.
@c Instrument only direct descendents and siblings in module tree by default.
@c Is this faster?
@c Control the modules inside the DUT with a DUT additive flags (you can use just one or a combination).
@c This flag should have self/descendents/siblings/all options.
@c Simulation annotations are a lowering that should exist as a nanopass pass.

For a module to be simulated, it must be contained within another module
(maybe make this a special type? @t{(driver ... (let (dut (instantiate
my-module))))} where @t{driver} is a macro wrapper for module & goodies)
inside of it.  The DUT is the simulation driver and must be marked with
a DUT flag.

The simulator must consume a module that has at least (at most?) one
module marked/annotated as the DUT@tie{}(Design Under Test).  This way
we only need to instrument (at least?) direct descendents.  If we create
an optional amount of DUT depth, we could control our observation of
signals.  The user could control the depth of the DUT module to
simulator only:
@itemize
@item
Self: Only the DUT module should have instrumentation.  This is only
useful for modules that are leaves in the module hierarchy.
@item
Descendents: The DUT module and all descendent modules are instrumented.
This is useful for multi-module simulation.
@item
Siblings: The DUT module and all sibling modules are instrumented.
NOTE: How is sibling defined?  How would this be useful?
@item
All: The DUT module and @emph{all modules} are instrumented.  This is
equivalent to how normal simulators handle things.
@end itemize

The reasoning behind this additional flag is that recording the values
of instrumented modules slows down simulation.  By only instrumenting
what is necessary, the simulator can run faster.

The addition of the DUT flag for simulation should be a pass in the
nanopass framework.  Where the flag(s) is/are generated will depend on a
value specified somewhere by the user.

@node Physical Simulation
@section Physical Simulation

@node Property-Based Testing
@section Property-Based Testing

@c Need reference for prop-based testing.
Another method of validation is the use of property-based testing.  This
is similar to formal verification, where the user provides a
specification of the behavior, but does so in the form of a
test/assertion. Then the computer will generate random inputs and
attempt to find an example that breaks your assertion.  A good
property-based tester also refines its counterexamples until it finds a
minimally-reproducible input that violates your assertion.  This is,
essentially, automated test-driven development.

@quotation NOTE
This is @b{not} formal verification!  Formal verification is a process
where the semantics of your hardware are proven against a
@emph{mathematical} model.

@b{Property-based testing is only testing, not proving.}
@end quotation

Ideally, the property-based tester and the simulator play together to
automatically run tests, kill the simulation, etc.  The simulator only
needs to be run if the item being tested needs to.  For instance, the
@t{log2up} function should work fine without running through a
simulator, because that is compile-/elaboration-time math.

@node Verification
@chapter Verification

A goal with Chil is to enable easier formal verification of both the
high-level Chil description and its lower-level outputs.  To this end,
the verifier will use the same Lisp syntax as the rest of Chil.

@node Synthesis
@chapter Synthesis

@node Interaction
@chapter Interaction

To interact with Chil, a command system will be built.  This system will
be composed of both compiled programs and scripts.  The goal here is to
have a minimal set of actions that allow the user to handle compiling
and building a Chil circuit.

@menu
* Tcl Compatibility::           Using Tcl/Tk scripts with Chil.
@end menu

@node Tcl Compatibility
@section Tcl Compatibility

Tcl is a string-oriented, lexically-scoped, dynamically-typed,
lately-bound, procedural scripting language.  See
@uref{https://www.tcl.tk, Tcl/Tk's home website} for in-depth
information.

For Chil to have any wide-spread usage in industrial areas,
compatibility @emph{and} integration with Tcl is a requirement.

Tcl2CL implements most of Tcl's scripting interface. When Tcl2CL
encounters a Tcl procedure it cannot understand, it is output literally.
This literal output allows for the conversion of scripts that use custom
procedures to a set of Chil instructions that can be executed by the
Chil system.

@node Resources
@chapter Resources
@c TODO: Make @defres macro for define-resource
@c See (texinfo) Definition Commands

@table @samp
@item Nanopass Compiler & Framework
@url{https://youtu.be/Os7FE3J-U5Q}@*
@url{https://nanopass.org/}@*
@url{https://andykeep.com/pubs/dissertation.pdf}

@item Timeline Types
@url{https://dl.acm.org/doi/abs/10.1145/3591234}

@item Spade HDL
@url{https://spade-lang.org/}@*
@url{https://zenodo.org/records/10149647}

@item Calyx@tie{}(an HDL IL)
@url{https://github.com/cucapra/calyx}@*
@url{https://rachit.pl/files/pubs/calyx.pdf}

@item Dahlia
@url{https://capra.cs.cornell.edu/dahlia/page/about/}

@item Veryl
@url{https://github.com/dalance/veryl}

@item Amaranth
@url{https://github.com/amaranth-lang/amaranth}@*
@url{https://amaranth-lang.org/docs/amaranth/latest/index.html}

@item Clash
@url{https://clash-lang.org/}@*
@url{https://github.com/clash-lang/clash-compiler}
@end table


@node Contributing
@chapter Contributing
@cindex documentation

Chil is documented using the Texinfo system.

@menu
* Style Guidelines::            Making all code look the same.
* Submitting Patches::          Sharing your work & improvements.
* Writing Documentation::       Improving & Writing documentation.
@end menu

@node Style Guidelines
@section Style Guidelines
This project uses
@uref{https://google.github.io/styleguide/lispguide.xml, Google's Common
Lisp style guide} as its guideline.  This document is freely available
online and contains, what I believe, are a good set of default style
points. Please read this document before submitting your changes to
ensure all of your modifications meet this style guide.  If your changes
have a good reason not to follow these guidelines, make sure you
document @emph{why} with appropriate comments.

@node Submitting Patches
@section Submitting Patches
When writing documentation, please use gender-neutral wording when
referring to people, such as
@uref{https://en.wikipedia.org/wiki/Singular_they, singular
``they''@comma{} ``their''@comma{} ``them''}, and so forth.

@quotation Heads Up
Please be sure to test your code with multiple Common Lisp
implementations before submitting your changes!  Chil is written using
ANSI-compliant Common Lisp, so any conforming implementation should
work.  Chil is currently tested with @uref{https://www.sbcl.org/, SBCL}
and @uref{https://ccl.clozure.com/, CCL}.
@end quotation

@node Writing Documentation
@section Writing Documentation

To render documentation, you must first make sure that you ran both
@command{./bootstrap} and @command{./configure} in your source tree.
After that you can run one of the following commands:

@itemize
@item @samp{make info} to compile the Info manual.
      You can check it with @command{info doc/chil.info}.
@item @samp{make doc/chil.info} to compile the Info manual.
      You can check it with @command{info doc/chil.info}.
@item @samp{make html} to compile the HTML version.
      You can point your browser to the relevant file in the
      @file{doc/chil.html} directory.
@item @samp{make doc/chil.html} to compile the HTML version.
      You can point your browser to the relevant file in the
      @file{doc/chil.html} directory.
@end itemize

@c *********************************************************************
@node Concept Index
@unnumbered Concept Index
@printindex cp

@node Programming Index
@unnumbered Programming Index
@syncodeindex tp fn
@syncodeindex vr fn
@printindex fn

@node Acronym Index
@unnumbered Acronym Index
@printindex ac

@bye

@c Local Variables:
@c ispell-local-dictionary: "american";
@c End:
