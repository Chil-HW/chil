\input texinfo
@c -*- texinfo -*-

@c %**start of header
@setfilename chil.info
@documentencoding UTF-8
@settitle Chil Reference Manual
@c %**end of header

@include version.texi

@copying
Copyright @copyright{} 2023 Raven Hallsby@*

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end copying

@titlepage
@title Chil Reference Manual
@subtitle Constructing Hardware in Lisp Language and Simulator
@author Raven Hallsby

@insertcopying
@end titlepage

@contents

@c *********************************************************************
@node Top
@top Chil

This document describes Chil version @value{VERSION}, a hardware
construction language and simulator.  Chil is inspired by
@uref{https://www.chisel-lang.org/, Chisel} and a variety of hardware
simulators.

@menu
* Introduction::                What is Chil?
* Hardware Language::           Chil, the language.
* Optimization::                Optimizing and lowering Chil.
* Code Generation::             Generating other HDLs and IR HDLs.
* Simulation::                  Simulating Chil.
* Verification::                Verifying Chil.
* Synthesis::                   Synthesizing Chil to hardware.
* Interaction::                 Using Chil from the command-line.
* Resources::                   Resources Chil used for inspiration.
* Contributing::                You can help too!
@end menu

@node Introduction
@chapter Introduction

@cindex purpose
Chil has multiple goals with many lofty goals.
Some or none of these may ever come to pass.

@enumerate
@item
Create and define an embedded domain-specific language@tie{}(EDSL), that
allows for expressing hardware in a reusable and composable way.
@item
Writing out a Chil design to another Hardware Description
Language@tie{}(HDL), whether it be Verilog, VHDL, FIRRTL, CIRCT, or any
other.
@item
When lowering a design from Chil's syntax to another language, use a
nanopass framework for optimizations, to make understanding a single
optimization easier and make adding additional optimization passes
simpler.
@item
Create a digital logic simulator that supports snapshotting, interactive
debugging, and time travel.
@item
Include a verification system to formally verify a design in the same
language as the design is written in.
@item
Synthesize to hardware, if possible.
@end enumerate

@node Hardware Language
@chapter Hardware Language

@uref{https://www.chisel-lang.org/, Chisel} introduced the world to
using an embedded domain-specific language@tie{}(EDSL) for hardware
design.  In many ways, this brought hardware design languages into the
21st Century.  Chisel allows for designs to:
@itemize
@item
Inherit from multiple sub-component definitions, through direct
object-oriented inheritance or through trait/typeclass/component
composition.
@item
Use functional programming ideas to improve the replication of portions
of the design.  Namely, Chisel uses a strong and strict type system,
makes heavy use of immutability, and frequently uses higher-order
functions to express repeatedly complex operations.
@end itemize

Chisel is built out of and on top of the
@uref{https://www.scala-lang.org/, Scala} software programming language.
While Scala is a fine language, it has some issues as well.  Most
notably (in the author's opinion) is the difficulty in creating new
Chisel components that require altering Chisel's internal behaviors.  As
an example, the author needed to have a directioned@footnote{This means
the input to one module connects to an output from another, as you would
expect. Chisel's default connection operator simply connects the first
signal in one module to the first signal in the other module, and so
on.} connection primitive for a Chisel design.  Chisel had that feature,
but only in the experimental package at the time.

@node Optimization
@chapter Optimization

Chil uses a nanopass optimization framework to optimize its high-level
description down to a lower-level language.  @uref{https://nanopass.org,
Nanopass optimization} is an idea from optimizing compiler design.  It
was first described in a whitepaper describing how to teach building
optimizing compilers
(@uref{https://legacy.cs.indiana.edu/~dyb/pubs/nano-jfp.pdf, original
description}). The core idea is that a single optimization pass should
perform just one easily-understood task which will be layered to perform
more advanced optimizations.

Most commercial compilers (including GCC and LLVM) implement
optimization passes that change large amounts of the program being
compiled in a single pass. A criticism of the original whitepaper was
that any nanopass compiler would not produce code as optimized as these
commercial compilers.  However, in Andrew Keep's
@uref{https://andykeep.com/pubs/dissertation.pdf, PhD thesis}, he showed
that many of these small passes is just as effective as commercial
compilers' larger ones.

Using a nanopass optimization methodology to compile Chil's high-level
description of a circuit down to a lower level means that new passes can
be added relatively easily.

Each of the currently supported passes is described in the following
sections.

@menu
* Pass 1::                      The first pass to run.
@end menu

@node Pass 1
@section Pass 1

This first pass does something.

@node Code Generation
@chapter Code Generation

Chil does @b{not} lock you into using Chil or its tools.  A variety of
backends are supported, allowing you to take your Chil designs
elsewhere, if you choose.

@menu
* Verilog::                     Chil generating Verilog.
* CIRCT::                       Chil generating LLVM CIRCT.
* FIRRTL::                      Chil generating Chisel FIRRTL.
@end menu

@node Verilog
@section Verilog

Chisel has targeted Verilog, because it is easier to generate correct
Verilog than VHDL or SystemVerilog.

@node CIRCT
@section CIRCT

CIRCT is an intermediate representation backed by LLVM and its
framework.

@node FIRRTL
@section FIRRTL

FIRRTL is an intermediate representation used by Chisel.

@node Simulation
@chapter Simulation

@menu
* Logic Simulation::            Simulating the design's logic.
* Physical Simulation::         Simulating the design's physics.
@end menu

@node Logic Simulation
@section Logic Simulation

Chil's simulator, like other HDL simulators, will simulate the design
under ideal digital conditions.  This means wires update their state
instantaneously, the clock is perfectly synchronized throughout the
physical layout, among other assumptions.  This is usually enough to
understand issues with the design at an early stage.

A critical feature in the design of Chil's digital simulator is
@b{@xref{Snapshotting}}.  With snapshotting, when an assertion about the
design is violated, the simulator generates a Common Lisp image with a
REPL that contains all the information about the design's simulation
preceding the violation.  The user is able to open and run this image
and inspect the state of the design at the time of the violation, and
even go backward in time!

For more in-depth simulation, namely of the physical properties of the
hardware, we turn to physical simulation @pxref{Physical Simulation}.

@menu
* Snapshotting::                Stopping the world and investigating.
@end menu

@node Snapshotting
@subsection Snapshotting

The key feature of Chil's simulator is its ability to ``snapshot'' the
design when an assertion is violated.  When such a violation occurs, a
Common Lisp core image is stored on-disk.  This image will include a
@emph{full} Common Lisp REPL inside it, allowing the user to interact
with the design.  Further, by construction, the image and REPL will
allow the user to travel back in time to @b{interactively investigate}
why the design experienced a violation.

@node Physical Simulation
@section Physical Simulation

@node Verification
@chapter Verification

A goal with Chil is to enable easier formal verification of both the
high-level Chil description and its lower-level outputs.  To this end,
the verifier will use the same Lisp syntax as the rest of Chil.

@node Synthesis
@chapter Synthesis

@node Interaction
@chapter Interaction

To interact with Chil, a command system will be built.  This system will
be composed of both compiled programs and scripts.  The goal here is to
have a minimal set of actions that allow the user to handle compiling
and building a Chil circuit.

@menu
* Tcl Compatibility::           Using Tcl/Tk scripts with Chil.
@end menu

@node Tcl Compatibility
@section Tcl Compatibility

Tcl is a string-oriented, lexically-scoped, dynamically-typed,
lately-bound, procedural scripting language.  See
@uref{https://www.tcl.tk, Tcl/Tk's home website} for in-depth
information.

For Chil to have any wide-spread usage in industrial areas,
compatibility @emph{and} integration with Tcl is a requirement.

Tcl2CL implements most of Tcl's scripting interface. When Tcl2CL
encounters a Tcl procedure it cannot understand, it is output literally.
This literal output allows for the conversion of scripts that use custom
procedures to a set of Chil instructions that can be executed by the
Chil system.

@node Resources
@chapter Resources
@c TODO: Make @defres macro for define-resource
@c See (texinfo) Definition Commands
@c Resource for making a nanopass compiler
@c https://youtu.be/Os7FE3J-U5Q

@node Contributing
@chapter Contributing
@cindex documentation

Chil is documented using the Texinfo system.

@menu
* Style Guidelines::            Making all code look the same.
* Submitting Patches::          Sharing your work & improvements.
* Writing Documentation::       Improving & Writing documentation.
@end menu

@node Style Guidelines
@section Style Guidelines
This project uses
@uref{https://google.github.io/styleguide/lispguide.xml, Google's Common
Lisp style guide} as its guideline.  This document is freely available
online and contains, what I believe, are a good set of default style
points. Please read this document before submitting your changes to
ensure all of your modifications meet this style guide.  If your changes
have a good reason not to follow these guidelines, make sure you
document @emph{why} with appropriate comments.

@node Submitting Patches
@section Submitting Patches
When writing documentation, please use gender-neutral wording when
referring to people, such as
@uref{https://en.wikipedia.org/wiki/Singular_they, singular
``they''@comma{} ``their''@comma{} ``them''}, and so forth.

@quotation Heads Up
Please be sure to test your code with multiple Common Lisp
implementations before submitting your changes!  Chil is written using
ANSI-compliant Common Lisp, so any conforming implementation should
work.  Chil is currently tested with @uref{https://www.sbcl.org/, SBCL}
and @uref{https://ccl.clozure.com/, CCL}.
@end quotation

@node Writing Documentation
@section Writing Documentation

To render documentation, you must first make sure that you ran both
@command{./bootstrap} and @command{./configure} in your source tree.
After that you can run one of the following commands:

@itemize
@item @samp{make info} to compile the Info manual.
      You can check it with @command{info doc/chil.info}.
@item @samp{make doc/chil.info} to compile the Info manual.
      You can check it with @command{info doc/chil.info}.
@item @samp{make html} to compile the HTML version.
      You can point your browser to the relevant file in the
      @file{doc/chil.html} directory.
@item @samp{make doc/chil.html} to compile the HTML version.
      You can point your browser to the relevant file in the
      @file{doc/chil.html} directory.
@end itemize

@bye

@c Local Variables:
@c ispell-local-dictionary: "american";
@c End:
