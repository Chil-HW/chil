#+TITLE: TODO

* Compilation Targets
A variety of compilation targets should be available, either for debugging or performance.
To make code "steppable" you must have set ~debug~ to be greater than ~speed~, ~space~, and ~compilation-speed~.
This can be done with the ~declaim~ function.

* Testing
  1. Property-based testing of pure functions.
     For example, ~chil:log2up~ should be property tested.
     This way I only have to write the properties required, and not any actual implementation.
     Possible candidates:
     * [[https://github.com/DalekBaldwin/check-it][check-it]] (Last update 2015-06-05)
     * [[https://github.com/mcandre/cl-quickcheck][cl-quickcheck]] (Last update 2020-05-08)
  2. Automated generation of test programs for modules requiring simulation.
     Interesting works in software:
     * [[https://dl.acm.org/doi/10.1145/3428264][YARPGen]]

* Higher-level Hardware
  1. Create higher-level versions of ~chil:module~ that is less painful to use, but can be converted into low-level Verilog-like format currently being used.
     Should support an implicit reset & clock, which can be overridden with a ~(with-reset/clock ...)~ macro(?).
     * Higher-level version should *NOT* have Verilog-specific information included in its definition.
       This includes things like ~timescale~.
       ~timescale~ should be handled at the Verilog level, but needs to be passed through as metadata attached to the higher-level module.
  2. This higher-level hardware should support things like mixins.
     Chisel has the ability to create a new module that ~extend~-s another, so that the new one inherits that hardware.
     It also has the ability to use composition, so you can say a signal "bundle" *must* and *will* contain these other signals, which have certain methods already defined for them.
     * See Chapter 2.1 (Hooks) of Common Lisp Condition System for underying idea on how to implement mixins similar to Chisel.
       Should use catch/signal/error/handler-bind for real thing though. See Chapter 2.2 for that.
     * Might want to use restarts instead?
     * Reference the [[https://lispcookbook.github.io/cl-cookbook][Common Lisp Cookbook]]
     * Investigate how [[https://github.com/Shirakumo/kandria][Kandria]] did mixins for their simulator.
       https://github.com/Shinmera/talks/tree/master
  3. One-way enum for FSM
     Specialization of an enum that only allows you to traverse in one direction.
     ~(next oneway-enum signal)~ moves you to next state when signal goes high.
     Special-case this because complicated FSMs typically have cycles in their control flow (looping).
  4. The equivalent to Chisel's ~Flipped~ constructor could be a macro that just switches all ~(inputs ...)~ to ~(outputs ...)~.
     ~(defmacro ... `(,module (inputs ,(module-outputs)) (outputs ,(module-inputs)) rest is same?)~

* Building/Elaborating
For any realistic Chil project, a build system will be needed to automate the work of taking a Chil description and lowering it to another format.
Look through [[https://www.microsoft.com/en-us/research/uploads/prod/2018/03/build-systems.pdf][Build Systems à la Carte]] for more information about this topic.

Implementing this could be done just by piggy-backing off of Common Lisp's already-present asdf.
Then for larger scale automation, some utilities may be provided.

** Notes after reading Build Systems à la Carte
We want a suspending scheduler for the build system, where each thread/process building the project can be paused until its inputs are ready.
But given Common Lisp's restart system, a restarting scheduler could be far more feasible.
Another problem for suspending scheduler is that Common Lisp does not have good support for continuation-passing style?

** Comparison to Chisel
Chisel uses the Scala Build System (SBT) to define and declare projects, and uses Java's default file hierarchy to find files.
But SBT does not work for projects that need to leave the Scala world?
Hence, larger projects like Chipyard need a combination of scripts, Makefiles, and Scala-generated Makefiles to make everything happen.

* Optimization
Within Chil, I would like to have an optimization framework for the higher-level language.
I am not sure how much optimization is possible in the long-run.
But for the small actively-working capacity of my mind, the [[https://github.com/nanopass][Nanopass Framework]] makes the most sense to me.

  1. I might have to implement the [[https://github.com/nanopass][Nanopass Framework]] in ANSI Common Lisp...
     * If I did that, I might be able to get that upstreamed?

* Outputs
Generate other low-level HDLs.
  1. FIRRTL?
  2. CIRCT?
  3. VHDL
  4. SystemVerilog

* Simulator
Chil should include a simulator alongside it.
Requirements:
  * Should be multi-threaded, to improve execution speed, if possible.
  * If a "core" assertion in the simulation testbench fails, then a Lisp core image should be saved (~sb-ext:save-lisp-and-die~).
  * This core image should allow for "rewinding" the world to see the sequence of events that caused an assertion violation.

Methods to achieve requirements:
  1. Simulator should use transactional memory?
     * [[https://stmx.org/][SMTX Common Lisp library]] makes it easy to use transactional memory in CL.
     * This may also make multithreading the simulator easier?
     * If the simulator's core image dump (~sb-ext:save-lisp-and-die~) includes the log of memory transactions internally, rewinding the image is simple, without dependencies.
     * [[https://spritely.institute/][Goblins]] implemented this with transactional heaps.
       [[https://spritely.institute/news/introducing-a-distributed-debugger-for-goblins-with-time-travel.html][Goblins Distributed Debugger with Time Travel]] is almost exactly what I would like.
     * Could use [[https://lfe.io/][Lisp Flavoured Erlang]] too, and have Erlang actors handle that.
       I don't know if there is a way for a "core dump" to be made though, as LFE compiles to BEAM bytecode and runs on top of there.
     * Transactional Heaps?
       - [[https://apps.dtic.mil/sti/pdfs/ADA306269.pdf][Safe and Efficient Persistent Heaps]]
       - [[https://dl.acm.org/doi/10.1145/1961295.1950380][NV-Heaps: Making Persistent Objects Fast and Safe]]
  2. Simulator must record the state changes in the circuit to a DB for rewind?
     Does the transactional memory allow that too?
     If the transaction log of memory allows for recording to disk, then replay should be somewhat trivial.
     * Jason recommended RRDTool as a time-series database.
       If a database is needed, that might make more sense.
  3. [[https://dspace.mit.edu/bitstream/handle/1721.1/44215/MIT-CSAIL-TR-2009-002.pdf?sequence=1&isAllowed=y][Propagators]]?

* Verification
  1. [[https://dl.acm.org/doi/10.1145/263699.263712][Proof-Carrying Code]]
  2. Compare/contrast with [[https://symbiyosys.readthedocs.io/en/latest/][SymbiYosis]], Yosys's front-end to formal HW verification flows

* Examples
  1. RISC-V core (Should support RISC-V GC, to boot Linux)
     Getting many of these built will make my stuff equivalent to [[https://github.com/ucb-bar/riscv-sodor][Berkeley's RISC-V SODOR]].
     1. Hardware support for single-, double-, and quad-precision floating point.
        See [[https://github.com/ucb-bar/berkeley-hardfloat][Berkeley's HardFloat]].
     2. Single-cycle
     3. Multi-cycle
     4. Pipelined (single issue)
     6. Multi-issue in-order pipelined
     7. Single-issue out-of-order
     8. Multi-issue out-of-order
  2. [[https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/][CHERI]] in Hardware
     This has already been done with ARM, MIPS, and recently RISC-V.
     But I want to implement on this.
  3. Custom architecture
